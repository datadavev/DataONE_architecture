..
  Warning: this file is automatically generated.  Edits will be lost


.. list-table:: Functions defined in :mod:`CN_authorization`
   :widths: 10 30
   :header-rows: 1

   * - Function
     - Parameters
   * - :func:`verifyToken`
     - (:class:`token<Types.AuthToken>`) ``->`` boolean
   * - :func:`isAuthorized`
     - (:class:`token<Types.AuthToken>`, :class:`guid<Types.Identifier>`,
       :class:`operation<Types.Event>`) ``->`` boolean
   * - :func:`setAccess`
     - (:class:`token<Types.AuthToken>`, :class:`guid<Types.Identifier>`,
       :class:`accessLevel<Types.AccessRule>`) ``->`` boolean



----

.. function:: verifyToken(token) -> boolean

   Test if the provided token is valid.

   The token is passed to the method end point using the normal authentication
   token transfer mechanism (e.g. HTTP Auth header).

   Note that there is a potential security issue here as open access to this
   method enables a malicious user to potentially probe a large number of
   generated tokens to determine properties of the system, and perhaps even
   generate a token that matches a system token. Hence another level of
   restriction (perhaps network level blocking / limiting) is necessary.

   :param token: The token to be tested.

   :type token: :class:`Types.AuthToken`

   :returns: True if the supplied token is valid, otherwise False.

   :rtype: boolean

   :raises Exceptions.ServiceFailure: ``(errorCode=500, detailCode=4550)``

   :raises Exceptions.NotAuthorized: ``(errorCode=401, detailCode=4540)``

     This error is raised if the request comes from a black listed source (e.g.
     a temporary block may be imposed on a source that calls this method too
     many times within some time interval)


   :raises Exceptions.NotImplemented: ``(errorCode=501, detailCode=4541)``

   :raises Exceptions.InvalidToken: ``(errorCode=401, detailCode=4555)``

   :raises Exceptions.InvalidRequest: ``(errorCode=400, detailCode=4542)``



----

.. function:: isAuthorized(token,guid,operation) -> boolean

   Test if the user identified by the provided token has authorization for
   operation on the specified object.

   .. Note:: Should perhaps add convenience methods for "canRead()" and
     "canWrite()" to verify that a user is able to read / write an object.

   Appears in functional use cases: :doc:`UC01 </UseCases/01_uc>`, :doc:`UC02
   </UseCases/02_uc>`, :doc:`UC36 </UseCases/36_uc>`, :doc:`UC37
   </UseCases/37_uc>`

   :param token:

   :type token: :class:`Types.AuthToken`

   :param guid:

   :type guid: :class:`Types.Identifier`

   :param operation:

   :type operation: :class:`Types.Event`

   :returns: True if the operation is allowed

   :rtype: boolean

   :raises Exceptions.ServiceFailure: ``(errorCode=500, detailCode=4600)``

   :raises Exceptions.InvalidToken: ``(errorCode=401, detailCode=4620)``

   :raises Exceptions.NotFound: ``(errorCode=404, detailCode=4560)``

   :raises Exceptions.NotAuthorized: ``(errorCode=401, detailCode=4580)``

     This error is raised if the request comes from a black listed source (e.g.
     a temporary block may be imposed on a source that calls this method too
     many times within some time interval)


   :raises Exceptions.NotImplemented: ``(errorCode=501, detailCode=4601)``

   :raises Exceptions.InvalidRequest: ``(errorCode=400, detailCode=4602)``



----

.. function:: setAccess(token,guid,accessLevel) -> boolean

   Sets the access permissions for an object identified by `guid`.

   Appears in functional use cases: :doc:`UC16 </UseCases/16_uc>`

   :param token: The authentication token returned by :func:`login`. Used to
     verify that the calling user has authority to modify access control for the
     object.

   :type token: :class:`Types.AuthToken`

   :param guid: The object for which access control is being edited.

   :type guid: :class:`Types.Identifier`

   :param accessLevel: The desired privileges to be assigned to the object.

   :type accessLevel: :class:`Types.AccessRule`

   :returns: True if the operation succeeds, otherwise false.

   :rtype: boolean

   :raises Exceptions.InvalidToken: ``(errorCode=401, detailCode=4410)``

     The supplied token is invalid


   :raises Exceptions.ServiceFailure: ``(errorCode=500, detailCode=4430)``

   :raises Exceptions.NotFound: ``(errorCode=404, detailCode=4400)``

     The specified object does not exist in the DataONE system


   :raises Exceptions.NotAuthorized: ``(errorCode=401, detailCode=4420)``

     The :term:`principal` does not have permission to alter access control
     rules for the object.


   :raises Exceptions.NotImplemented: ``(errorCode=501, detailCode=4401)``

   :raises Exceptions.InvalidRequest: ``(errorCode=400, detailCode=4402)``

.. TODO::
    Should permissions cascade? e.g. Should setting permission on a Data Package
    cascade to the contained objects as well (the experiment metadata and data)?


