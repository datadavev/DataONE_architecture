Use Case 09 - Replicate MN to MN
--------------------------------

Author
  VDC TWG

Date
  - 20091001 Filled out description a bit more
  - 20090925 Adding to use case description and documentation
  - 20090114 (TWG meeting).  Subsequent various modifications.

Version 
  Draft

Goal
  Replicate data from Member Node to Member Node.

Summary 

  Replication of content between Member Nodes (MN) is done to improve
  persistence of information (avoid data loss with loss of MN) and to improve
  accessibility (more choices for content retrieval can lower bandwidth
  requirements for any particular MN). The process of replication may be
  facilitated by a Coordinating Node (CN), or perhaps only between MNs. The
  interaction diagram presented here follows the former notion, where
  replication is facilitated by a CN.

  A full copy of a data package is made during the replication process, so the
  original experiment metadata and data is copied to the recipient MN. An
  important question is whether that content is stored in it's original form
  (for data this must be the case) or translated into a form that is supported
  by the MN (likely to be the case for experiment metadata).  

  If experiment metadata is translated into a local dialect by a recipient MN,
  then it is important that the original metadata is preserved on the CNs, as
  it is always possible that the original MN where the content was published
  may go offline or be removed from the DataONE system.
  


Actors
  Member Node x2, Coordinating Node

Preconditions 
  - Content is present on a Member Node
  
Triggers
 - New data is available on a Member Node

 - Information on a Member Node is altered

 - Capabilities of a Member Node changes (accepting more or less content)

 - Replication policy of DataONE or a Member Node changes


Post Conditions
  - Content is present on one more Member Node

  - System metadata is updated to reflect the change

  - Watchers are notified of the change

  - Member Node and Coordinating Node logs are updated


.. figure:: images/09_interaction.png
   :width: 100%

   Interactions for use case 09.


..
  @startuml images/09_interaction.png
  !include ../plantuml.conf
  title Interactions: 09 - Replicate data from Member Node to Member Node

  participant "CRUD API" as m_crud << Member Node >>
  participant "State of Health API" as c_health << Coordinating Node >>
  c_health -> m_crud: ping()
  activate c_health
    c_health <-- m_crud: [ACK, NewData]
  participant "Synchronization API" as c_sync << Coordinating Node >>
    c_health -> c_sync: scheduleSync(MN_ID)
  deactivate c_health

  participant "Replication API" as m_rep << Member Node >>
  c_sync -> m_rep: listChangedRecords(auth_token)
  note right of c_sync
    The RSS mechanism might be 
    appropriate for retrieving changes.
    auth_token identifies the CN 
    retrieving content.
  end note
  c_sync <-- m_rep: GUID_list

  loop for each GUID
    c_sync -> c_sync: getReplicas(GUID)
    note right: Update of existing copies.
    loop for each replica
      c_sync -> c_sync: addUpdateTask(MN, GUID)
    end
    c_sync -> c_sync: getTargetMNs(GUID)
    note right of c_sync
      The MN ids returned are valid targets
      for the data package identified by GUID,
      including consideration of size, access
      rules, and so forth.
    end note
    loop for each MN
      c_sync -> c_sync: addUpdateTask(MN, GUID)
    end
  end

  m_rep -> c_sync


  participant "Replication API" as c_rep << Coordinating Node >>
  participant "CRUD API" as m_crud_a << Member Node A >>
  m_crud_a -> c_rep: replicateMetadata ()
  participant "CRUD API" as c_crud << Coordinating Node >>
  c_rep -> c_crud: write ()
  c_rep <-- c_crud: ack
  c_rep -> m_crud_a: ack
  c_rep -> c_rep: isReplicationNeeded ()
  c_rep -> c_rep: T or F
  c_rep -> c_rep: getMNReplicateList ()
  c_rep -> c_rep: replicaList
  participant "Replication API" as m_rep_b << Member Node B >>
  c_rep -> m_rep_b: startReplica (ID, sessionID, transID, srcMN)
  m_crud_a -> m_rep_b: read (ID, sess, transID)
  participant "Authorization API" as c_authorize << Coordinating Node >>
  m_crud_a -> c_authorize: isAuthorized (sess, transID)
  m_crud_a <-- c_authorize: T or F
  m_crud_a -> m_rep_b: object
  c_rep -> m_rep_b: replicationSucceeds (transID)
  c_rep -> m_rep_b: cancelReplication (sess, transID)
  c_rep <-- m_rep_b: ack
  @enduml


.. raw:: latex

   \newpage

